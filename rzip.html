<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>漫画阅读器</title>
    <style>
        #comic {
            /* overflow-y: scroll; */
            overflow-x: hidden;
            white-space: normal;
            height: auto; /* 根据需要调整 */
        }
        .comic-page {
            page-break-after: always;
            padding: 10px;
            text-align: center;
        }
        .comic-page img {
            max-width: 100%;
            max-height: 100%;
        }
        #loading {
            text-align: center;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div id="loading">加载中...</div>
    <div id="comic"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
    <script>
        // 从 URL 查询参数中获取漫画的 URL
        var urlParams = new URLSearchParams(window.location.search);
        var comicUrl = urlParams.get('comic_url');
        // 将filenames作为全局变量
        var filenames = []; // 声明为全局变量
        var currentPageIndex = 0;
        var zip = null;
        var comicContainer = document.getElementById("comic");
        var loadingElement = document.getElementById("loading");

        function fileComparator(a, b) {
            // 使用 padStart 来确保文件名长度一致，然后基于字符串排序
            const filenameA = a.padStart(10, '0').slice(-10); // 假设文件名最多有10位
            const filenameB = b.padStart(10, '0').slice(-10');
            return filenameA.localeCompare(filenameB, undefined, { numeric: true });
        }
        
        function loadComic() {
            loadingElement.style.display = 'block';
            fetch(comicUrl)
                .then(response => response.blob())
                .then(blob => JSZip.loadAsync(blob))
                .then(zipFile => {
                    zip = zipFile;
                    // 获取所有文件名，并筛选出图片文件
                    let filenamesLocal = Object.keys(zip.files).filter(name => !zip.files[name].dir && name.endsWith('.jpg'));
                    // 使用自定义排序函数对图片文件名进行排序
                    filenamesLocal.sort(fileComparator);
                    // 更新全局变量 filenames
                    filenames = filenamesLocal;
                    pageCount = filenames.length;
        
                    // 显示第一张图片
                    if (filenames.length > 0) {
                        displayImage(filenames[currentPageIndex], zip);
                    }
        
                    // 监听滚动事件（如果需要滚动加载，则取消注释下面这行代码）
                    // comicContainer.addEventListener('scroll', handleScrollEvent);
        
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert("加载漫画失败");
                })
                .finally(() => {
                    loadingElement.style.display = 'none';
                });
        }
        
        // 如果需要滚动加载图片，取消注释下面的函数和事件监听器
        /*
        function handleScrollEvent() {
            if (canLoadNextImage()) {
                // 加载下一张图片的逻辑
            }
        }
        
        comicContainer.addEventListener('scroll', handleScrollEvent);
        */
        
        function displayImage(filename, zipObject) {
            // 创建一个新的图片容器
            const pageDiv = document.createElement("div");
            pageDiv.className = "comic-page";
        
            // 异步加载图片数据
            zipObject.file(filename).async("base64").then(function(base64) {
                const imgElement = new Image();
                imgElement.src = "data:image/jpeg;base64," + base64;
                imgElement.onload = () => {
                    // 当图片加载完成后，将其添加到页面容器中
                    pageDiv.appendChild(imgElement);
                    comicContainer.appendChild(pageDiv);
                    // 如果需要滚动加载，可以在这里添加加载下一张图片的逻辑
                };
            }).catch(function(error) {
                console.error('Error:', error);
            });
        }
        
        // 页面加载后自动加载漫画
        loadComic();
    </script>
</body>
</html>
